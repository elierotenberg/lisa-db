import { join, relative } from "path";
import { promisify } from "util";
import { promises } from "fs";
import * as t from "typed-assert";
import glob from "glob";
import fetch from "node-fetch";
import matter from "gray-matter";
import { camelCase } from "change-case";
import { GuideMeta, parseGuideMeta } from "../lib/Content/GuideMeta";
import { DomainMeta, parseDomainMeta } from "../lib/Content/DomainMeta";
import {
  InstitutionMeta,
  parseInstitutionMeta,
} from "../lib/Content/InstitutionMeta";
import { PersonMeta, parsePersonMeta } from "../lib/Content/PersonMeta";
import { ContentFile } from "../lib/Content/Content";

const main = async () => {
  const contentRoot = join(__dirname, "..", "content", "db");

  const mediaRoot = join(__dirname, "..", "..", "public", "media");

  const globAsync = promisify(glob);
  const errors: { readonly file: string; readonly error: Error }[] = [];

  const mdxFiles = (
    await globAsync(join(contentRoot, "**/*.mdx")).then((files) =>
      Promise.all(
        files.map(async (file) => {
          try {
            const fileContents = await promises.readFile(file, {
              encoding: "utf-8",
            });
            const { data: meta, content: raw } = matter(fileContents);
            return { file, raw, meta };
          } catch (error) {
            errors.push({ file, error });
            return null;
          }
        })
      )
    )
  ).filter(t.check(t.isNotNull));
  const domains: ContentFile<DomainMeta>[] = [];
  const guides: ContentFile<GuideMeta>[] = [];
  const institutions: ContentFile<InstitutionMeta>[] = [];
  const persons: ContentFile<PersonMeta>[] = [];
  for (const { file, meta, raw } of mdxFiles) {
    try {
      t.isRecord(meta);
      t.isString(meta.kind);
      const { kind } = meta;
      if (kind === "guide") {
        guides.push({ file, meta: parseGuideMeta(meta), raw });
      } else if (kind === "domain") {
        domains.push({ file, meta: parseDomainMeta(meta), raw });
      } else if (kind === "institution") {
        institutions.push({
          file,
          meta: parseInstitutionMeta(meta),
          raw,
        });
      } else if (kind === "person") {
        persons.push({ file, meta: parsePersonMeta(meta), raw });
      }
    } catch (error) {
      errors.push({ file, error });
    }
  }

  console.log("Downloading person pictures...");

  await Promise.all(
    persons.map(async (person) => {
      const pictureData = await (
        await fetch(person.meta.picture_href)
      ).arrayBuffer();
      const file = join(mediaRoot, "person", "picture", person.meta.slug);
      await promises.writeFile(file, Buffer.from(pictureData));
      console.log(`Saved ${file}`);
      Object.assign(person.meta, {
        picture_href: `/media/person/picture/${person.meta.slug}`,
      });
    })
  );

  const contents = {
    domains,
    guides,
    institutions,
    persons,
  };

  console.log({
    domains: contents.domains.length,
    errors: errors.length,
    guides: contents.guides.length,
    institution: contents.institutions.length,
    persons: contents.persons.length,
  });

  if (errors.length > 0) {
    console.error("The following errors occured:");
    for (const { file, error } of errors) {
      console.error(file);
      console.error(error);
      console.error();
    }
  }

  const prelude = `
  /** 
   * THIS FILE IS GENERATED BY A SCRIPT 
   *        ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
   *        âš ï¸âš ï¸âš ï¸âš ï¸
   *    DO NOT EDIT MANUALLY!
   *        ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
   *        âš ï¸âš ï¸âš ï¸âš ï¸
   **/
  import { Contents, Content } from "../../lib/Content/Content";
  import { GuideMeta } from "../../lib/Content/GuideMeta";
  import { DomainMeta } from "../../lib/Content/DomainMeta";
  import { InstitutionMeta } from "../../lib/Content/InstitutionMeta";
  import { PersonMeta } from "../../lib/Content/PersonMeta";
  `;

  const imports: string[] = [];
  const declarations: string[] = [];
  for (const [kind, contents, contentType] of [
    ["domains", domains, "DomainMeta"],
    ["guides", guides, "GuideMeta"],
    ["institutions", institutions, "InstitutionMeta"],
    ["persons", persons, "PersonMeta"],
  ] as const) {
    const localDeclarations: string[] = [];
    for (const { file, meta, raw } of contents) {
      const relativeFile = relative(contentRoot, file);
      const mdxId = camelCase(relativeFile);
      imports.push(`import ${mdxId} from "./${relativeFile}";`);
      localDeclarations.push(`
      {
        meta: ${JSON.stringify(meta, null, 2)},
        raw: ${JSON.stringify(raw)},
        Mdx: ${mdxId},
      }
      `);
    }
    declarations.push(
      `const ${kind}: Content<${contentType}>[] = [${localDeclarations.join(
        `,\n`
      )}];`
    );
    declarations.push("");
  }
  declarations.push(`
    export const contents: Contents = {
      domains,
      guides,
      institutions,
      persons,
    };
  `);

  const out = [prelude, ...imports, "", ...declarations].join("\n");

  await promises.writeFile(join(contentRoot, "index.ts"), out, {
    encoding: "utf8",
  });
};

if (require.main !== module) {
  console.error("This should be the main module.");
  process.exit(1);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
